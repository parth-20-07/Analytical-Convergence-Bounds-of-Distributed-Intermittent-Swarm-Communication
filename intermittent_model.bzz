taskID = 0
networkToReach = -1
networkID = -1
curiosity = 0.0
stepsSinceStart = 0
utility = 1.0
a = 1.0
b = 1.0
#flow = 1.0
connectability = 0.1
rotationRadius = 2.0
centerX = 0
centerY = 0


function init() {
	math.rng.setseed(id)
	#gotoNetworkOrigins[0][0] = -2;
	#gotoNetworkOrigins[0][1] = -2;
	#gotoNetworkOrigins[1][0] = 2;
	#gotoNetworkOrigins[1][1] = 2;
	taskID = 0
	networkToReach = -1
	networkID = -1
	curiosity = 0.0
	stepsSinceStart = 0
	utility = 1.0
	a = 1.0
	b = 1.0
	#flow = 1.0
	connectability = 0.1
	if((id == 0)){
		networkID = 0
		networkToReach = 0
	}
	if((id == 1)){
		networkID = 1
		networkToReach = 1
	}	
}

function calculateDistanceFromCentroid(){
	posX = pose.position.x
	posY = pose.position.y

	eX = (posX-centerX)^2
	eY = (posY-centerY)^2
	distance = math.sqrt(eX + eY)

	return distance
}

function rotateAroundCentroid(){
	# gotop(10.0,0.0)
	# log(id, "Revolving Around centroid")
}

function Task0(){
	if(calculateDistanceFromCentroid()>= rotationRadius){
		rotationSpeed = 2.5
		yaw = pose.orientation.yaw

		posX = pose.position.x
		posY = pose.position.y

		dX = centerX - posX
		dY = centerY - posY

		theta = math.atan(dY, dX)
		# Orienting towards centroid
		if (theta > yaw+0.05)
			{
				set_wheels(-rotationSpeed,rotationSpeed)
				return
			}
		else if (theta < yaw-0.05)
			{
				set_wheels(rotationSpeed,-rotationSpeed)
				return
			}
		
			# Moving towards centroid
		log(id, "D: ", distance, " Moving towards centroid")
		movementSpeed = 10.0
		set_wheels(movementSpeed,movementSpeed)
		return
	}
	else{
		rotateAroundCentroid()
	}
}

function goToNetworkOrigin( networkIndex ){
	if(networkIndex == 1){
		centerX = 2
		centerY = 2
	}
	else{
		centerX = -2
		centerY = -2
	}
}

function evaluatePhi(){
	return (a * 1) - (b*(curiosity * connectability))
}

function updateVariables(){
	stepsSinceStart = stepsSinceStart + 1

	if(taskID == 0){
		curiosity = curiosity + 1.0;
		#connectability = math.sqrt()#distance between current position and goto
		#check for if it is becoming a data mule. If it is, send a packet to inform the network.
		if(evaluatePhi() < 0.0){
			if(networkToReach == 0){
				networkToReach = 1
			}else{
				networkToReach = 0
			}
			#networkToReach = !networkID
			taskID = 1
			#broadcast to neighbors, "reset curiosoty"
		}
	}
	#else{
		#if a neighbor exists, if it is of unique network ID, change task and broadcast packets as needed. Adopt neighbors network ID.
		#possibility for "handshake" task swapping
		
	#}
}

function step() {
	isLeader = ((id == 0) or (id == 10))
	if( isLeader or (taskID == 1)){
		goToNetworkOrigin(networkToReach)
	}else{
		Task0()
	}

	updateVariables()
}


# This function is executed when you press the reset button
function reset() {
}

# This function is executed once when you close the simulator
function destroy() {
}
