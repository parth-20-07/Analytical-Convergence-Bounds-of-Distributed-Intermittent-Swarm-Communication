	
	taskID = 0

	networkToReach = -1

	networkID = -1
	
	curiosity = 0.0

	stepsSinceStart = 0

	utility = 1.0

	a = 1.0
	b = 1.0
	
	#flow = 1.0
	connectability = 0.1


function init() {
	math.rng.setseed(id)

	#gotoNetworkOrigins[0][0] = -2;
	#gotoNetworkOrigins[0][1] = -2;

	#gotoNetworkOrigins[1][0] = 2;
	#gotoNetworkOrigins[1][1] = 2;

	taskID = 0

	networkToReach = -1

	networkID = -1
	
	curiosity = 0.0

	stepsSinceStart = 0

	utility = 1.0

	a = 1.0
	b = 1.0
	
	#flow = 1.0
	connectability = 0.1

	if((id == 0)){
		networkID = 0
		networkToReach = 0
	}

	if((id == 1)){
		networkID = 1
		networkToReach = 1
	}	
}



function Task0(){
	#carry out task 0 
}

function goToNetworkOrigin( networkIndex ){

	goToPointx = -2
	goToPointy = -2 	
	
	if(networkIndex == 1){
		goToPointx = 2
		goToPointy = 2 		
	}
	
	#gotopointx = gotoNetworkOrigins[networkIndex][0]
	#gotopointy = gotoNetworkOrigins[networkIndex][1]
	#
	
	
}

function evaluatePhi(){
	return (a * 1) - (b*(curiosity * connectability))
}

function updateVariables(){
	stepsSinceStart = stepsSinceStart + 1

	if(taskID == 0){
		curiosity = curiosity + 1.0;
		#connectability = math.sqrt()#distance between current position and goto
		#check for if it is becoming a data mule. If it is, send a packet to inform the network.
		if(evaluatePhi() < 0.0){
			if(networkToReach == 0){
				networkToReach = 1
			}else{
				networkToReach = 0
			}
			#networkToReach = !networkID
			taskID = 1
			#broadcast to neighbors, "reset curiosoty"
		}
	}
	#else{
		#if a neighbor exists, if it is of unique network ID, change task and broadcast packets as needed. Adopt neighbors network ID.
		#possibility for "handshake" task swapping
		
	#}
}

function step() {
	isLeader = ((id == 0) or (id == 10))
	if( isLeader or (taskID == 1)){
		goToNetworkOrigin(networkToReach)
	}else{
		Task0()
	}

	updateVariables()
}


# This function is executed when you press the reset button
function reset() {
}

# This function is executed once when you close the simulator
function destroy() {
}
